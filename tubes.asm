ORG 00H
	; 8-BIT CALCULATOR
	; R0 IS USED FOR COMMANDS AND DATA ON THE LCD
	; R1 HOLDS THE FIRST NUMBER
	; R2 SAVE THE OPERATION
	; R3 HOLDS THE SECOND NUMBER
	; PORT P3 - KEYBOARD INPUT
	; PORT P2 - RESET + 2 PINS OF THE LCD (E and RS))
	; PORT P1 - OUTPUT TO LCD
	NOVONUM EQU P3.0 ; P2.7 IS HIGH WHEN WRITING SECOND NUMBER
	NOVODIG EQU P3.1 ; P2.6 IS LOW ONLY WHEN WRITING FIRST DIGIT OF A NUMBER
	RS EQU P3.5 ; RS ON LCD
	RW EQU P3.7 ; RW ON LCD
        row4 bit P2.0
        row3 bit P2.1
        row2 bit P2.2
        row1 bit P2.3
	col1 bit P2.4
        col2 bit P2.5
        col3 bit P2.6
        col4 bit P2.7

	;COMMANDS TO PREPARE LCD TO WRITE ON SCREEN
	
	MOV R0, #38H     	;USES TWO LINES AND 5X7 MATRIX
	ACALL COMMAND    	;CHAMA A ROTINA PARA EXECUTAR O COMANDO NO LCD
	MOV R0, #0EH   		;DISPLAY LIGADO/CURSOR PISCANDO
	ACALL COMMAND    	
	MOV R0, #80H   		;COLOCAR CURSOR NA PRIMEIRA LINHA
	ACALL COMMAND  		
	MOV R0, #01H     	;LIMPA TELA DE EXIBI??O
	ACALL COMMAND		
	
	MOV R4, #00H   		;ZERAR O REGISTRADOR R4
	MOV P3, #00H		;ZERAR PORTA P2 
	MOV P2, #0FEH		;IN?CIO DO LDC COM L1 EM GROUND (LINHA 1 ATIVA) 
	MOV R3, #00H		;ZERAR O REGISTRADOR R3
	MOV R1, #00H		;ZERAR O REGISTRADOR R1
	MOV R2, #'+'		;CASO SE DIGITE S? IGUAL OU S? UM N?MERO E IGUAL
L1:	
	JNB row4, C1		;SALTA PARA C1 SE FOR 0 (SEMPRE COME?A EM 0)
	JNB row3, C2		;SALTA PARA C2 SE FOR 0
	JNB row2, C3		;SALTA PARA C3 SE FOR 0
	JNB row1, C4		;SALTA PARA C4 SE FOR 0
	SJMP L1			;RETORNA ? CHECAGEM DAS LINHAS
	
C1:	JNB col1, SALTO_BOT_ON		;SALTA SE O BOT?O ON FOR APERTADO
	JNB col2, SALTO_BOT_ZERO	;SALTA SE O BOT?O '0' FOR APERTADO
	JNB col3, SALTO_BOT_IGUAL	;SALTA SE O BOT?O '=' FOR APERTADO
	JNB col4, SALTO_BOT_MAIS	;SALTA SE O BOT?O '+' FOR APERTADO
	SETB row4			;DESATIVA LINHA 1
	CLR row3			;ATIVA LINHA 2
	SJMP L1				;RETORNA ? CHECAGEM DAS LINHAS
	

C2:	JNB col1, SALTO_BOT_1		;SALTA SE O BOT?O '1' FOR APERTADO
	JNB col2, SALTO_BOT_2		;SALTA SE O BOT?O '2' FOR APERTADO
	JNB col3, SALTO_BOT_3		;SALTA SE O BOT?O '3' FOR APERTADO
	JNB col4, SALTO_BOT_MENOS	;SALTA SE O BOT?O '-' FOR APERTADO
	SETB row3			;DESATIVA LINHA 2
	CLR row2			;ATIVA LINHA 3
	SJMP L1				;RETORNA ? CHECAGEM DAS LINHAS
	
C3:	JNB col1, SALTO_BOT_4		;SALTA SE O BOT?O '4' FOR APERTADO
	JNB col2, SALTO_BOT_5		;SALTA SE O BOT?O '5' FOR APERTADO
	JNB col3, SALTO_BOT_6		;SALTA SE O BOT?O '6' FOR APERTADO
	JNB col4, SALTO_BOT_VEZES	;SALTA SE O BOT?O 'x' FOR APERTADO
	SETB row2			;DESATIVA LINHA 3
	CLR row1			;ATIVA LINHA 4
	SJMP L1				;RETORNA ? CHECAGEM DAS LINHAS

C4:	JNB col1, SALTO_BOT_7		;SALTA SE O BOT?O '7' FOR APERTADO
	JNB col2, SALTO_BOT_8		;SALTA SE O BOT?O '8' FOR APERTADO
	JNB col3, SALTO_BOT_9		;SALTA SE O BOT?O '9' FOR APERTADO
	JNB col4, SALTO_BOT_DIVISAO	;SALTA SE O BOT?O '/' FOR APERTADO
	SETB row1			;DESATIVA LINHA 4
	CLR row4			;ATIVA LINHA 1
	LJMP L1				;RETORNA ? CHECAGEM DAS LINHAS (LJMP SALTO GRANDE)

SALTO_BOT_ON: LJMP BOT_ON		
SALTO_BOT_ZERO: LJMP BOT_ZERO		
SALTO_BOT_1: LJMP BOT_1			
SALTO_BOT_2: LJMP BOT_2			
SALTO_BOT_3: LJMP BOT_3			
SALTO_BOT_4: LJMP BOT_4			
SALTO_BOT_5: LJMP BOT_5			
SALTO_BOT_6: LJMP BOT_6			
SALTO_BOT_7: LJMP BOT_7			
SALTO_BOT_8: LJMP BOT_8			
SALTO_BOT_9: LJMP BOT_9			
SALTO_BOT_MAIS: LJMP BOT_MAIS		
SALTO_BOT_MENOS: LJMP BOT_MENOS		
SALTO_BOT_VEZES: LJMP BOT_VEZES		
SALTO_BOT_DIVISAO: LJMP BOT_DIVISAO	
SALTO_BOT_IGUAL: LJMP BOT_IGUAL		

BOT_ON: 	SETB P3.6	;ATIVAR O RESET
		LJMP L1		

BOT_ZERO: 	MOV R0, #'0'	;MOVER O CARACTERE '0' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME O CARACTERE NO LCD
		LJMP L1		

BOT_IGUAL: 	MOV R0, #'='	;MOVER O CARACTERE '=' PARA R0		
		ACALL DISPLAY	;IMPRIME NA TELA
		ACALL RESULTADO	;REALIZA A OPERA??O
		LJMP L1		

BOT_MAIS: 	MOV R0, #'+'	;MOVER O CARACTERE '+' PARA R0	
		ACALL OPERACAO	;GUARDA A OPERA??O EM R2
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_1: 		MOV R0, #'1'	;MOVER O CARACTERE '1' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_2: 		MOV R0, #'2'	;MOVER O CARACTERE '2' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_3: 		MOV R0, #'3'	;MOVER O CARACTERE '3' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_MENOS: 	MOV R0, #'-'	;MOVER O CARACTERE '-' PARA R0	
		ACALL OPERACAO	;GUARDA A OPERA??O EM R2
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_4: 		MOV R0, #'4'	;MOVER O CARACTERE '4' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_5: 		MOV R0, #'5'	;MOVER O CARACTERE '5' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_6: 		MOV R0, #'6'	;MOVER O CARACTERE '6' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_VEZES: 	MOV R0, #'*'	;MOVER O CARACTERE '*' PARA R0	
		ACALL OPERACAO	;GUARDA A OPERA??O EM R2
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_7: 		MOV R0, #'7'	;MOVER O CARACTERE '7' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_8: 		MOV R0, #'8'	;MOVER O CARACTERE '8' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_9: 		MOV R0, #'9'	;MOVER O CARACTERE '9' PARA R0	
		ACALL NUMERO	;GUARDA O N?MERO
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		

BOT_DIVISAO: 	MOV R0, #'/'	;MOVER O CARACTERE '/' PARA R0	
		ACALL OPERACAO	;GUARDA A OPERA??O EM R2
		ACALL DISPLAY	;IMPRIME NA TELA
		LJMP L1		


DISPLAY:   
	MOV P1, R0	;MOVE O CARACTERE PARA A SA?DA (P1) 
	SETB RS    	;COLOCA RS (REGISTER SELECT) NO MODO DE DADOS
	SETB RW     	;LIBERA PERMISS?O DE LEITURA/ESCRITA NO LCD (N?VEL ALTO)
	CLR RW 	
	ACALL DELAY  	;CHAMA UM DELAY DE 0.25s (IMPEDIR QUE IMPRIMA V?RIAS VEZES)
	RET 		

COMMAND:   
	MOV P1, R0  	;MOVE O COMANDO PARA A PORTA DE SA?DA - ENTRADA DO LCD 
	CLR RS     	;COLOCA RS (REGISTER SELECT) NO MODO DE COMANDO
	SETB RW    	;LIBERA PERMISS?O DE LEITURA/ESCRITA NO LCD (N?VEL ALTO)
	CLR RW	
	ACALL DELAY	;CHAMA UM DELAY DE 0.25s
	RET    		


NUMERO: 
	JB NOVONUM, SEGUNDONUM	;SALTA SE FOR O SEGUNDO N?MERO
	JB NOVODIG, NOVODIGITO	;SALTA SE N?O FOR O PRIMEIRO D?GITO DO PRIMEIRO N?MERO
	MOV A, R0		;MOVE O CARACTERE PARA O ACUMULADOR
	SUBB A, #30H		;TRANFORMA ESSE CARACTERE NO EQUIVALENTE NUM?RICO
	MOV R1, A		;GUARDA ESSE N?MERO NO REGISTRADOR R1
	SETB NOVODIG		;SETAR PINO NOVODIG => PRIMEIRO D?GITO DO PRIMEIRO N?MERO FOI GUARDADO
	RET			

NOVODIGITO: 
	MOV A, R0			;MOVE O NOVO CARACTERE PARA O ACUMULADOR
	MOV B, #10D			;MOVE A CONSTANTE 10 PARA O ACUMULADOR AUXILIAR
	SUBB A, #30H			;TRANFORMA ESSE CARACTERE NO EQUIVALENTE NUM?RICO
	MOV R7, A			;MOVE RESULTADO PARA O REGISTRADOR R7
	MOV A, R1			;MOVE O N?MERO ATUAL (PRIMEIRO N?MERO) PARA O ACUMULADOR
	MUL AB				;MULTIPLICA O N?MERO ATUAL POR 10 
	MOV R6, B 			;GUARDA A PARTE MAIS SIGNIFICATIVA EM R6
	CJNE R6, #00H, SALTO_ESTOURO	;CASO HAJA ALGUM VALOR EM B OU R6, EXCEDEU 8 BITS
	ADD A, R7			;SE N?O EXCEDEU, SOMA O (N?MERO ATUAL X 10) COM O NOVO D?GITO
	JC SALTO_ESTOURO		;SE O CARRY FOR 1, A SOMA EXCECEU 8 BITS (SALTA PARA LABEL ESTOURO)
	MOV R1, A			;MOVE RESULTADO DO PRIMEIRO N?MERO PARA O REGISTRADOR R1
	SETB NOVODIG			;SETAR PINO NOVODIG => NOVO N?MERO FOI GUARDADO
	RET				
	
SEGUNDONUM:
	JB NOVODIG, NOVODIGITO2	;SALTA SE N?O FOR O PRIMEIRO D?GITO DO SEGUNDO N?MERO
	MOV A, R0		;MOVE O CARACTERE PARA O ACUMULADOR
	SUBB A, #30H		;TRANFORMA ESSE CARACTERE NO EQUIVALENTE NUM?RICO
	MOV R3, A		;GUARDA ESSE N?MERO NO REGISTRADOR R3
	SETB NOVODIG		;SETAR PINO NOVODIG => PRIMEIRO D?GITO DO SEGUNDO N?MERO FOI GUARDADO
	RET			;RETORNA

NOVODIGITO2: 
	MOV A, R0		;MOVE O NOVO CARACTERE PARA O ACUMULADOR
	MOV B, #10D		;MOVE A CONSTANTE 10 PARA O ACUMULADOR AUXILIAR
	SUBB A, #30H		;TRANFORMA ESSE CARACTERE NO EQUIVALENTE NUM?RICO
	MOV R7, A		;MOVE RESULTADO PARA O REGISTRADOR R7
	MOV A, R3		;MOVE O N?MERO ATUAL (SEGUNDO N?MERO) PARA O ACUMULADOR
	MUL AB			;MULTIPLICA O N?MERO ATUAL POR 10 
	MOV R6, B 		;GUARDA A PARTE MAIS SIGNIFICATIVA EM R6
	CJNE R6, #00H, SALTO_ESTOURO	;CASO HAJA ALGUM VALOR EM B OU R6, EXCEDEU 8 BITS
	ADD A, R7			;SE N?O EXCEDEU, SOMA O (N?MERO ATUAL X 10) COM O NOVO D?GITO
	JC SALTO_ESTOURO		;SE O CARRY FOR 1, A SOMA EXCECEU 8 BITS (SALTA PARA LABEL ESTOURO)
	MOV R3, A			;MOVE RESULTADO DO SEGUNDO N?MERO PARA O REGISTRADOR R1
	SETB NOVODIG			;SETAR PINO NOVODIG => NOVO N?MERO FOI GUARDADO
	RET				

OPERACAO:
	SETB NOVONUM		;SETA NOVONUM, INDICANDO QUE PR?XIMO D?GITO ? DO SEGUNDO N?MERO
	CLR NOVODIG		;LIMPA NOVODIG, INDICANDO QUE O PR?XIMO D?GITO SER? O PRIMEIRO
	MOV A, R0		;MOVE O CARACTERE DA OPERA??O PARA O ACUMULADOR
	MOV R2, A		;MOVE O CARACTERE DA OPERA??O PARA R2
	RET			


RESULTADO:
	CJNE R2, #'+', SUBTRACAO	;VERIFICA SE A OPERA??O ? SOMA
	MOV A, R1			;MOVER O PRIMEIRO N?MERO PARA O ACUMULADOR
	CLR C 				;LIMPA O CARRY
	ADD A, R3			;SOMA O PRIMEIRO N?MERO COM O SEGUNDO N?MERO
	JC SALTO_ESTOURO		;SE O CARRY FOR 1, A SOMA EXCECEU 8BITS (SALTA PARA LABEL ESTOURO)
	MOV R5, #0H			;MOVE 0 PARA O REGISTRADOR R5 (N?O TEM RESTO - N?O DECIMAL)
	MOV R4, A			;GUARDA O RESULTADO DA SOMA EM R4
	LJMP IMPRIMIR			;SALTA PARA A LABEL IMPRIMIR
SUBTRACAO: 
	CJNE R2, #'-', MULTIPLICACAO	;VERIFICA SE A OPERA??O ? SUBTRA??O
	MOV A, R1			;MOVER O PRIMEIRO N?MERO PARA O ACUMULADOR
	CLR C 				;LIMPA O CARRY
	SUBB A, R3			;SUBTRAI O SEGUNDO N?MERO DO PRIMEIRO N?MERO
	JC SALTO_ESTOURO		;SE O CARRY FOR 1, A SOMA EXCECEU 8BITS (SALTA PARA LABEL ESTOURO)
	MOV R5, #0H			;MOVE 0 PARA O REGISTRADOR R5 (N?O TEM RESTO - N?O DECIMAL)
	MOV R4, A			;GUARDA O RESULTADO DA SOMA EM R4
	LJMP IMPRIMIR			;SALTA PARA A LABEL IMPRIMIR
	
MULTIPLICACAO:
	CJNE R2, #'*', DIVISAO		;VERIFICA SE A OPERA??O ? MULTIPLICA??O
	MOV A, R1			;MOVER O PRIMEIRO N?MERO PARA O ACUMULADOR
	MOV B, R3			;MOVER O SEGUNDO N?MERO PARA O ACUMULADOR AUXILIAR
	MUL AB				;MULTIPLICAR O PRIMEIRO N?MERO PELO SEGUNDO N?MERO
	MOV R7, B 			;GUARDA A PARTE MAIS SIGNIFICATIVA EM R7
	CJNE R7, #0H, ESTOURO		;CASO HAJA ALGUM VALOR EM B OU R7, EXCEDEU 8 BITS 
	MOV R5, #0H			;MOVE 0 PARA O REGISTRADOR R5 (N?O TEM RESTO - N?O DECIMAL)
	MOV R4, A			;GUARDA O RESULTADO DA SOMA EM R4
	LJMP IMPRIMIR			;SALTA PARA A LABEL IMPRIMIR
	
DIVISAO:				;OPERA??O DE DIVIS?O
	MOV A, R1			;MOVER O PRIMEIRO N?MERO PARA O ACUMULADOR
	MOV B, R3			;MOVER O SEGUNDO N?MERO PARA O ACUMULADOR AUXILIAR
	DIV AB				;DIVIDIR O PRIMEIRO N?MERO PELO SEGUNDO N?MERO
	MOV R4, A			;GUARDA O RESULTADO DA SOMA EM R4
	MOV R5, B 			;GUARDA A PARTE MAIS SIGNIFICATIVA EM R5
	LJMP IMPRIMIR			;SALTA PARA A LABEL IMPRIMIR

SALTO_ESTOURO: 	LJMP ESTOURO		;LABEL COM SALTO LONGO PARA LABEL ESTOURO
		

IMPRIMIR:
	CJNE R3, #0D, NORMAL		;SALTA SE O SEGUNDO N?MERO FOR DIFERENTE DE ZERO
	CJNE R2, #'/', NORMAL		;SALTA SE A OPERA??O N?O FOR DIVIS?O 
	MOV R0, #0C0H			;COLOCAR CURSOR NA SEGUNDA LINHA
	ACALL COMMAND			;CHAMA A ROTINA PARA EXECUTAR COMANDOS NO LCD
	MOV DPTR, #MSGERRO		;MOVE ENDERE?O DO VETOR PARA O REGISTRADOR DPTR (DIVIS?O POR ZERO)
	CLR C				;LIMPA O CARRY
	MOV R7, #0D			;MOVE 0 PARA O REGISTRADOR R7
PROX:	MOV A, R7			;MOVE O CONTE?DO DE R7 PARA O ACUMULADOR
	MOVC A, @A+DPTR			;MOVE O CONTE?DO ENDERE?ADO POR A+DPTR PARA A
	MOV R0, A			;MOVE RESULTADO PARA O REGISTRADOR R0
	ACALL DISPLAY			;IMPRIME NO LCD
	INC R7				;SE N?O FOR 0, INCREMENTA R7
	JNZ PROX			;SE N?O FOR ZERO, PULA PARA LABEL PROX
	RET				
					
NORMAL:	MOV R7, #100D			;MOVE A CONSTANTE 100 PARA O REGISTRADOR R7
	CLR C 				;LIMPA O CARRY (PARA N?O INFERFERIR NA SUBTRA??O)
	SUBB A, R7			;SUBTRAIR 100 DO RESULTADO 
	JC MENOR100			;SE O CARRY FOR 1, O RESULTADO ? < 100 - SALTA PARA LABEL MENOR100
	MOV A, R4			;MOVE RESULTADO PARA O ACUMULADOR NOVAMENTE (N?MERO DE 3 D?GITOS)
	MOV B, R7			;MOVE A CONSTANTE 100 PARA O REGISTRADOR ACUMULADOR AUXILIAR
	DIV AB				;DIVIDE O RESULTADO POR 100 PARA PEGAR O TERCEIRO D?GITO
	ADD A, #30H			;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A			;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (CENTENA)
	ACALL DISPLAY			;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (CENTENA)
	MOV R4, B 			;MOVE O RESTO DA DIVIS?O POR 100 PARA R4			
	MOV A, B 			;MOVE O RESTO DA DIVIS?O POR 100 PARA O ACUMULADOR
	MOV R7, #10D			;MOVE A CONSTANTE 10 PARA O REGISTRADOR R7
	MOV B, R7			;MOVE A CONSTANTE 10 PARA O REGISTRADOR ACUMULADOR AUXILIAR
	DIV AB				;DIVIDE O RESTO DA DIVIS?O POR 100, AGORA POR 10
	ADD A, #30H			;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A			;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (DEZENA)
	ACALL DISPLAY			;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (DEZENA)
	MOV A, B			;MOVE O RESTO DA DIVIS?O POR 10 PARA O ACUMULADOR
	ADD A, #30H			;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A			;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (UNIDADE)
	ACALL DISPLAY			;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (UNIDADE)
	CJNE R5, #00H, DECIMAL		;SE O RESTO DA OPERA??O DIVIS?O N?O FOR 0, PULA PRA LABEL DECIMAL
	RET
	
MENOR100: MOV R7, #10D			;MOVE A CONSTANTE 10 PARA O REGISTRADOR R7
	CLR C 				;LIMPA O CARRY (PARA N?O INFERFERIR NA SUBTRA??O)
	MOV A, R4			;MOVE RESULTADO PARA O ACUMULADOR
	SUBB A, R7			;SUBTRAIR 10 DO RESULTADO 
	JC MENOR10			;SE O CARRY FOR 1, O RESULTADO ? < 10 - SALTA PARA LABEL MENOR10
	MOV A, R4			;MOVE RESULTADO PARA O ACUMULADOR NOVAMENTE (N?MERO DE 2 D?GITOS)
	MOV B, R7			;MOVE A CONSTANTE 10 PARA O ACUMULADOR AUXILIAR
	DIV AB				;DIVIDE O RESULTADO POR 10 PARA PEGAR O SEGUNDO D?GITO
	ADD A, #30H			;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A			;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (DEZENA)
	ACALL DISPLAY			;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (DEZENA)
	MOV A, B 			;MOVE O RESTO DA DIVIS?O POR 10 PARA O ACUMULADOR
	ADD A, #30H			;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A			;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (UNIDADE)
	ACALL DISPLAY			;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (UNIDADE)
	CJNE R5, #00H, DECIMAL		;SE O RESTO DA OPERA??O DIVIS?O N?O FOR 0, PULA PRA LABEL DECIMAL
	RET				

MENOR10:
	MOV A, R4			;MOVE RESULTADO PARA O ACUMULADOR
	ADD A, #30H			;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A			;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (UNIDADE)
	ACALL DISPLAY			;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (UNIDADE)
	CJNE R5, #00H, DECIMAL		;SE O RESTO DA OPERA??O DIVIS?O N?O FOR 0, PULA PRA LABEL DECIMAL
	RET				


ESTOURO:
	MOV R0, #0C0H		;COLOCAR CURSOR NA SEGUNDA LINHA
	ACALL COMMAND		;CHAMA A LABEL PARA EXECUTAR O COMANDO NO LCD
	MOV DPTR, #MSGERRO2	;MOVE ENDERE?O DO VETOR PARA O REGISTRADOR DPTR
	CLR C			;LIMPA O CARRY
	MOV R7, #0D		;MOVE 0 PARA O REGISTRADOR R7
PROX2:	MOV A, R7		;MOVE O CONTE?DO DE R7 PARA O ACUMULADOR
	MOVC A, @A+DPTR		;MOVE O CONTE?DO ENDERE?ADO POR A+DPTR para A
	MOV R0, A		;MOVE RESULTADO PARA O REGISTRADOR R0
	ACALL DISPLAY		;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD
	JZ FIM			;QUANDO CHEGAR NO ZERO, PULA PARA LABEL FIM
	INC R7			;SE N?O FOR 0, INCREMENTA R7
	SJMP PROX2		;SALTA PARA A LABEL PROX2 (LOOP PARA ESCREVER A MENSAGEM)
FIM:	
	RET			


DECIMAL: MOV R0, #'.'		;MOVE CARACTERE '.' PARA O REGISTRADOR R0
	ACALL DISPLAY		;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD
	MOV A, R5		;MOVE RESTO DA DIVIS?O PARA O ACUMULADOR
	MOV B, #10D		;MOVE A CONSTANTE 10 PARA O ACUMULADOR AUXILIAR
	MUL AB			;MULTIPLICA O RESTO DA DIVIS?O POR 10
	MOV B, R3		;MOVE O DIVISOR (SEGUNDO N?MERO) PARA O ACUMULADOR AUXILIAR
	DIV AB			;DIVIDE (RESTOX10) PELO SEGUNDO N?MERO DE NOVO
	ADD A, #30H		;TRANFORMA O N?MERO NO CARACTERE EQUIVALENTE
	MOV R0, A		;MOVE O CARACTERE EQUIVALENTE PARA O RESGISTRADOR R0 (PARTE DECIMAL)
	ACALL DISPLAY		;CHAMA A LABEL PARA IMPRIMIR O CARACTERE NA TELA DO LCD (UNIDADE)
	RET			


DELAY:	MOV 62, #2		;APLICAR DELAY DE 0.25s
DELAY1:	MOV 61, #250
DELAY2:	MOV 60, #250	
	DJNZ 60, $
	DJNZ 61, DELAY2
	DJNZ 62, DELAY1
	RET

;DB - DEFINE BYTE (INICIALIZA A MEM?RIA)
MSGERRO: DB 'ERRO: DIV POR 0',0		;VETOR DA MENSAGEM DE ERRO - DIVIS?O POR ZERO!
MSGERRO2: DB 'OVERFLOW!',0		;VETOR DA MENSAGEM DE ERRO - EXCEDEU 8 BITS/N?MERO NEGATIVO

	END				;FIM DO PROGRAMA